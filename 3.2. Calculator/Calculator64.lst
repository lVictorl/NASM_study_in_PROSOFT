     1                                  section .data
     2                                      ; Сегмент данных - константы и сообщения
     3 00000000 456E7465722031206E-         prompt1 db "Enter 1 number: ", 0
     3 00000009 756D6265723A2000   
     4 00000011 456E7465722032206E-         prompt2 db "Enter 2 number: ", 0
     4 0000001A 756D6265723A2000   
     5 00000022 416E737765723A2000          answer db "Answer: ", 0
     6 0000002B 0A                          newline db 10
     7 0000002C 4572726F723A204661-         error_read db "Error: Failed to read input", 10, 0
     7 00000035 696C656420746F2072-
     7 0000003E 65616420696E707574-
     7 00000047 0A00               
     8 00000049 4572726F723A204661-         error_write db "Error: Failed to write output", 10, 0
     8 00000052 696C656420746F2077-
     8 0000005B 72697465206F757470-
     8 00000064 75740A00           
     9 00000068 4572726F723A204E75-         error_range db "Error: Number out of 64-bit range", 10, 0
     9 00000071 6D626572206F757420-
     9 0000007A 6F662036342D626974-
     9 00000083 2072616E67650A00   
    10 0000008B 4572726F723A20496E-         error_format db "Error: Invalid number format", 10, 0
    10 00000094 76616C6964206E756D-
    10 0000009D 62657220666F726D61-
    10 000000A6 740A00             
    11 000000A9 4572726F723A20456D-         error_empty db "Error: Empty input is not allowed", 10, 0
    11 000000B2 70747920696E707574-
    11 000000BB 206973206E6F742061-
    11 000000C4 6C6C6F7765640A00   
    12 000000CC 4572726F723A204172-         error_overflow db "Error: Arithmetic overflow", 10, 0
    12 000000D5 6974686D6574696320-
    12 000000DE 6F766572666C6F770A-
    12 000000E7 00                 
    13                                      
    14                                      ; Константы для проверки диапазона 64-битных чисел
    15                                      ; (добавлены как данные, а не как непосредственные значения)
    16 000000E8 CCCCCCCCCCCCCC0C            max_positive_div10 dq 922337203685477580   ; 2^63/10
    17 000000F0 34333333333333F3            min_negative_div10 dq -922337203685477580  ; -2^63/10
    18                                  
    19                                  section .bss
    20                                      ; Сегмент неинициализированных данных - буферы
    21 00000000 <res 40h>                   buffer resb 64      ; Буфер для ввода числа
    22 00000040 ????????????????            num1 resq 1         ; Первое число (64 бит)
    23 00000048 ????????????????            num2 resq 1         ; Второе число (64 бит)
    24 00000050 <res 20h>                   result_str resb 32  ; Строка для результата
    25                                  
    26                                  section .text
    27                                      global _start
    28                                  
    29                                  ; ======================== ГЛАВНАЯ ПРОГРАММА ========================
    30                                  _start:
    31                                      ; ВВОД ПЕРВОГО ЧИСЛА
    32 00000000 BF01000000                  mov rdi, 1
    33 00000005 E8CF000000                  call read_number
    34 0000000A 4885C0                      test rax, rax       ; проверка на ошибку
    35 0000000D 0F85A6020000                jnz error_exit
    36                                      
    37                                      ; ВВОД ВТОРОГО ЧИСЛА
    38 00000013 BF02000000                  mov rdi, 2
    39 00000018 E8BC000000                  call read_number
    40 0000001D 4885C0                      test rax, rax       ; проверка на ошибку
    41 00000020 0F8593020000                jnz error_exit
    42                                      
    43                                      ; ВЫЧИСЛЕНИЕ СУММЫ
    44 00000026 488B0425[40000000]          mov rax, [num1]     ; загружаем первое число (64 бит)
    45 0000002E 488B1C25[48000000]          mov rbx, [num2]     ; загружаем второе число (64 бит)
    46 00000036 4801D8                      add rax, rbx        ; складываем числа
    47 00000039 0F80BC010000                jo overflow_error   ; проверка на переполнение
    48                                      
    49                                      ; ПРЕОБРАЗОВАНИЕ РЕЗУЛЬТАТА В СТРОКУ
    50 0000003F 48BF-                       mov rdi, result_str ; буфер для строки
    50 00000041 [5000000000000000] 
    51 00000049 E890030000                  call int64_to_string ; вызов функции преобразования 64-битного числа
    52                                      
    53                                      ; ВЫВОД РЕЗУЛЬТАТА
    54 0000004E 48BE-                       mov rsi, answer     ; "Answer: "
    54 00000050 [2200000000000000] 
    55 00000058 E868020000                  call strlen
    56 0000005D 4889C2                      mov rdx, rax        ; EDX = длина строки
    57 00000060 B801000000                  mov rax, 1          ; sys_write
    58 00000065 BF01000000                  mov rdi, 1          ; stdout
    59 0000006A 0F05                        syscall
    60 0000006C 4883F800                    cmp rax, 0          ; проверка успешности записи
    61 00000070 0F8C5D010000                jl write_error      ; если ошибка
    62                                      
    63                                      ; Вычисляем длину строки результата
    64 00000076 48BE-                       mov rsi, result_str
    64 00000078 [5000000000000000] 
    65 00000080 E840020000                  call strlen
    66 00000085 4889C2                      mov rdx, rax        ; EDX = длина строки
    67                                      
    68 00000088 B801000000                  mov rax, 1          ; вывод самого числа
    69 0000008D BF01000000                  mov rdi, 1          ; stdout
    70 00000092 48BE-                       mov rsi, result_str
    70 00000094 [5000000000000000] 
    71 0000009C 0F05                        syscall
    72 0000009E 4883F800                    cmp rax, 0          ; проверка успешности записи
    73 000000A2 0F8C2B010000                jl write_error      ; если ошибка
    74                                      
    75 000000A8 B801000000                  mov rax, 1          ; новая строка
    76 000000AD BF01000000                  mov rdi, 1
    77 000000B2 48BE-                       mov rsi, newline
    77 000000B4 [2B00000000000000] 
    78 000000BC BA01000000                  mov rdx, 1
    79 000000C1 0F05                        syscall
    80 000000C3 4883F800                    cmp rax, 0          ; проверка успешности записи
    81 000000C7 0F8C06010000                jl write_error      ; если ошибка
    82                                      
    83                                      ; УСПЕШНОЕ ЗАВЕРШЕНИЕ ПРОГРАММЫ
    84 000000CD B83C000000                  mov rax, 60         ; sys_exit
    85 000000D2 BF00000000                  mov rdi, 0          ; код возврата 0
    86 000000D7 0F05                        syscall
    87                                  
    88                                  ; ======================== ФУНКЦИЯ ВВОДА ЧИСЛА ========================
    89                                  ; Функция читает и проверяет число, возвращает в num1 или num2
    90                                  ; Вход: RDI - номер числа (1 или 2)
    91                                  read_number:
    92 000000D9 55                          push rbp
    93 000000DA 4889E5                      mov rbp, rsp
    94 000000DD 53                          push rbx
    95 000000DE 4154                        push r12
    96                                      
    97 000000E0 4989FC                      mov r12, rdi        ; сохраняем номер числа
    98                                      
    99                                      ; Определяем какое число вводим (1 или 2)
   100 000000E3 4983FC01                    cmp r12, 1
   101 000000E7 750C                        jne .second_number
   102                                      
   103                                  .first_number:
   104 000000E9 48BE-                       mov rsi, prompt1
   104 000000EB [0000000000000000] 
   105 000000F3 EB0A                        jmp .print_prompt
   106                                      
   107                                  .second_number:
   108 000000F5 48BE-                       mov rsi, prompt2
   108 000000F7 [1100000000000000] 
   109                                      
   110                                  .print_prompt:
   111                                      ; ВЫВОД ПРИГЛАШЕНИЯ
   112 000000FF E8C1010000                  call strlen
   113 00000104 4889C2                      mov rdx, rax        ; длина строки
   114 00000107 B801000000                  mov rax, 1          ; sys_write
   115 0000010C BF01000000                  mov rdi, 1          ; stdout
   116 00000111 0F05                        syscall
   117 00000113 4883F800                    cmp rax, 0          ; проверка успешности записи
   118 00000117 7C71                        jl .read_error
   119                                      
   120                                      ; ЧТЕНИЕ ВВОДА
   121 00000119 B800000000                  mov rax, 0          ; sys_read
   122 0000011E BF00000000                  mov rdi, 0          ; stdin
   123 00000123 48BE-                       mov rsi, buffer     ; буфер для ввода
   123 00000125 [0000000000000000] 
   124 0000012D BA40000000                  mov rdx, 64         ; максимальная длина
   125 00000132 0F05                        syscall
   126 00000134 4883F800                    cmp rax, 0          ; проверка успешности чтения
   127 00000138 7C50                        jl .read_error
   128 0000013A 745A                        jz .empty_error     ; если ничего не прочитано
   129                                      
   130                                      ; ПРОВЕРКА ДЛИНЫ ВВОДА
   131 0000013C 4883F840                    cmp rax, 64
   132 00000140 7D60                        jge .too_long_error
   133                                      
   134                                      ; УДАЛЕНИЕ СИМВОЛА НОВОЙ СТРОКИ
   135 00000142 E894010000                  call remove_newline
   136                                      
   137                                      ; ПРОВЕРКА НА ПУСТОЙ ВВОД
   138 00000147 E8AC010000                  call check_empty_string
   139 0000014C 4885C0                      test rax, rax
   140 0000014F 7545                        jnz .empty_error
   141                                      
   142                                      ; ПРЕОБРАЗОВАНИЕ СТРОКИ В 64-БИТНОЕ ЧИСЛО
   143 00000151 48BE-                       mov rsi, buffer     ; RSI = указатель на строку
   143 00000153 [0000000000000000] 
   144 0000015B E8C2010000                  call string_to_int64 ; вызов функции преобразования
   145                                      
   146                                      ; ПРОВЕРКА РЕЗУЛЬТАТА ПРЕОБРАЗОВАНИЯ
   147 00000160 4883F800                    cmp rax, 0          ; успех?
   148 00000164 7443                        je .save_number
   149 00000166 4883F801                    cmp rax, 1          ; ошибка формата?
   150 0000016A 7406                        je .format_error
   151 0000016C 4883F802                    cmp rax, 2          ; ошибка диапазона?
   152 00000170 740C                        je .range_error
   153                                      
   154                                  .format_error:
   155 00000172 E804010000                  call format_error_handler
   156 00000177 B801000000                  mov rax, 1
   157 0000017C EB46                        jmp .done
   158                                      
   159                                  .range_error:
   160 0000017E E8D9000000                  call range_error_handler
   161 00000183 B801000000                  mov rax, 1
   162 00000188 EB3A                        jmp .done
   163                                      
   164                                  .read_error:
   165 0000018A E88F000000                  call read_error_handler
   166 0000018F B801000000                  mov rax, 1
   167 00000194 EB2E                        jmp .done
   168                                      
   169                                  .empty_error:
   170 00000196 E8FF000000                  call empty_error_handler
   171 0000019B B801000000                  mov rax, 1
   172 000001A0 EB22                        jmp .done
   173                                      
   174                                  .too_long_error:
   175                                      ; Ошибка слишком длинного ввода
   176 000001A2 B801000000                  mov rax, 1
   177 000001A7 EB1B                        jmp .done
   178                                  
   179                                  .save_number:
   180                                      ; Сохраняем число в num1 или num2
   181 000001A9 4983FC01                    cmp r12, 1
   182 000001AD 750A                        jne .save_num2
   183 000001AF 48891C25[40000000]          mov [num1], rbx     ; сохраняем первое число (64 бит)
   184 000001B7 EB08                        jmp .success
   185                                      
   186                                  .save_num2:
   187 000001B9 48891C25[48000000]          mov [num2], rbx     ; сохраняем второе число (64 бит)
   188                                      
   189                                  .success:
   190 000001C1 4831C0                      xor rax, rax        ; успешное завершение
   191                                      
   192                                  .done:
   193 000001C4 415C                        pop r12
   194 000001C6 5B                          pop rbx
   195 000001C7 5D                          pop rbp
   196 000001C8 C3                          ret
   197                                  
   198                                  ; ======================== ОБРАБОТЧИКИ ОШИБОК ========================
   199                                  read_error:
   200 000001C9 E850000000                  call read_error_handler
   201 000001CE E9E6000000                  jmp error_exit
   202                                  
   203                                  write_error:
   204 000001D3 E865000000                  call write_error_handler
   205 000001D8 E9DC000000                  jmp error_exit
   206                                  
   207                                  range_error:
   208 000001DD E87A000000                  call range_error_handler
   209 000001E2 E9D2000000                  jmp error_exit
   210                                  
   211                                  format_error:
   212 000001E7 E88F000000                  call format_error_handler
   213 000001EC E9C8000000                  jmp error_exit
   214                                  
   215                                  empty_error:
   216 000001F1 E8A4000000                  call empty_error_handler
   217 000001F6 E9BE000000                  jmp error_exit
   218                                  
   219                                  overflow_error:
   220 000001FB 48BE-                       mov rsi, error_overflow
   220 000001FD [CC00000000000000] 
   221 00000205 E8BB000000                  call strlen
   222 0000020A 4889C2                      mov rdx, rax
   223 0000020D B801000000                  mov rax, 1
   224 00000212 BF01000000                  mov rdi, 1
   225 00000217 0F05                        syscall
   226 00000219 E99B000000                  jmp error_exit
   227                                  
   228                                  read_error_handler:
   229 0000021E 48BE-                       mov rsi, error_read
   229 00000220 [2C00000000000000] 
   230 00000228 E898000000                  call strlen
   231 0000022D 4889C2                      mov rdx, rax
   232 00000230 B801000000                  mov rax, 1
   233 00000235 BF01000000                  mov rdi, 1
   234 0000023A 0F05                        syscall
   235 0000023C C3                          ret
   236                                  
   237                                  write_error_handler:
   238 0000023D 48BE-                       mov rsi, error_write
   238 0000023F [4900000000000000] 
   239 00000247 E879000000                  call strlen
   240 0000024C 4889C2                      mov rdx, rax
   241 0000024F B801000000                  mov rax, 1
   242 00000254 BF01000000                  mov rdi, 1
   243 00000259 0F05                        syscall
   244 0000025B C3                          ret
   245                                  
   246                                  range_error_handler:
   247 0000025C 48BE-                       mov rsi, error_range
   247 0000025E [6800000000000000] 
   248 00000266 E85A000000                  call strlen
   249 0000026B 4889C2                      mov rdx, rax
   250 0000026E B801000000                  mov rax, 1
   251 00000273 BF01000000                  mov rdi, 1
   252 00000278 0F05                        syscall
   253 0000027A C3                          ret
   254                                  
   255                                  format_error_handler:
   256 0000027B 48BE-                       mov rsi, error_format
   256 0000027D [8B00000000000000] 
   257 00000285 E83B000000                  call strlen
   258 0000028A 4889C2                      mov rdx, rax
   259 0000028D B801000000                  mov rax, 1
   260 00000292 BF01000000                  mov rdi, 1
   261 00000297 0F05                        syscall
   262 00000299 C3                          ret
   263                                  
   264                                  empty_error_handler:
   265 0000029A 48BE-                       mov rsi, error_empty
   265 0000029C [A900000000000000] 
   266 000002A4 E81C000000                  call strlen
   267 000002A9 4889C2                      mov rdx, rax
   268 000002AC B801000000                  mov rax, 1
   269 000002B1 BF01000000                  mov rdi, 1
   270 000002B6 0F05                        syscall
   271 000002B8 C3                          ret
   272                                  
   273                                  error_exit:
   274                                      ; ЗАВЕРШЕНИЕ ПРОГРАММЫ С ОШИБКОЙ
   275 000002B9 B83C000000                  mov rax, 60         ; sys_exit
   276 000002BE BF01000000                  mov rdi, 1          ; код возврата 1 (ошибка)
   277 000002C3 0F05                        syscall
   278                                  
   279                                  ; ======================== ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ========================
   280                                  
   281                                  ; ФУНКЦИЯ: strlen
   282                                  ; Назначение: Вычисляет длину строки
   283                                  ; Вход: RSI - указатель на строку
   284                                  ; Выход: RAX - длина строки
   285                                  strlen:
   286 000002C5 51                          push rcx
   287 000002C6 4889F1                      mov rcx, rsi
   288 000002C9 4831C0                      xor rax, rax
   289                                  .count_loop:
   290 000002CC 803900                      cmp byte [rcx], 0
   291 000002CF 7408                        je .done
   292 000002D1 48FFC0                      inc rax
   293 000002D4 48FFC1                      inc rcx
   294 000002D7 EBF3                        jmp .count_loop
   295                                  .done:
   296 000002D9 59                          pop rcx
   297 000002DA C3                          ret
   298                                  
   299                                  ; ФУНКЦИЯ: remove_newline
   300                                  ; Назначение: Удаляет символ новой строки из конца строки в buffer
   301                                  remove_newline:
   302 000002DB 48BF-                       mov rdi, buffer
   302 000002DD [0000000000000000] 
   303                                  .search_loop:
   304 000002E5 8A07                        mov al, [rdi]
   305 000002E7 3C00                        cmp al, 0
   306 000002E9 740C                        je .done
   307 000002EB 3C0A                        cmp al, 10
   308 000002ED 7405                        je .found_newline
   309 000002EF 48FFC7                      inc rdi
   310 000002F2 EBF1                        jmp .search_loop
   311                                  .found_newline:
   312 000002F4 C60700                      mov byte [rdi], 0
   313                                  .done:
   314 000002F7 C3                          ret
   315                                  
   316                                  ; ФУНКЦИЯ: check_empty_string
   317                                  ; Назначение: Проверяет, является ли строка в buffer пустой
   318                                  check_empty_string:
   319 000002F8 48BF-                       mov rdi, buffer
   319 000002FA [0000000000000000] 
   320 00000302 4831C0                      xor rax, rax
   321                                  .check_loop:
   322 00000305 8A0F                        mov cl, [rdi]
   323 00000307 84C9                        test cl, cl
   324 00000309 7411                        jz .is_empty
   325 0000030B 80F920                      cmp cl, 32
   326 0000030E 7407                        je .next_char
   327 00000310 80F909                      cmp cl, 9
   328 00000313 7402                        je .next_char
   329 00000315 EB0A                        jmp .not_empty
   330                                  .next_char:
   331 00000317 48FFC7                      inc rdi
   332 0000031A EBE9                        jmp .check_loop
   333                                  .is_empty:
   334 0000031C B801000000                  mov rax, 1
   335                                  .not_empty:
   336 00000321 C3                          ret
   337                                  
   338                                  ; ФУНКЦИЯ: string_to_int64
   339                                  ; Назначение: Преобразует строку в 64-битное целое число со знаком
   340                                  ; Вход: RSI - указатель на строку
   341                                  ; Выход: RAX = 0 (успех), RBX = число; RAX = 1 (ошибка формата), RAX = 2 (ошибка диапазона)
   342                                  string_to_int64:
   343 00000322 55                          push rbp
   344 00000323 4889E5                      mov rbp, rsp
   345 00000326 51                          push rcx
   346 00000327 52                          push rdx
   347 00000328 4150                        push r8
   348 0000032A 4151                        push r9
   349 0000032C 4152                        push r10
   350                                      
   351 0000032E 4831DB                      xor rbx, rbx        ; обнуляем результат (будет в RBX)
   352 00000331 4D31C0                      xor r8, r8          ; флаг знака (0 = положительное)
   353 00000334 B90A000000                  mov rcx, 10         ; основание системы счисления
   354                                      
   355                                      ; ПРОВЕРКА ПУСТОЙ СТРОКИ
   356 00000339 803E00                      cmp byte [rsi], 0
   357 0000033C 0F8486000000                je .format_error
   358                                      
   359                                      ; ПРОВЕРКА ЗНАКА
   360 00000342 803E2D                      cmp byte [rsi], '-' ; отрицательное число?
   361 00000345 750B                        jne .check_plus
   362 00000347 41B801000000                mov r8, 1           ; устанавливаем флаг отрицательного
   363 0000034D 48FFC6                      inc rsi             ; пропускаем знак '-'
   364 00000350 EB08                        jmp .after_sign
   365                                  
   366                                  .check_plus:
   367 00000352 803E2B                      cmp byte [rsi], '+' ; явный плюс?
   368 00000355 7503                        jne .after_sign
   369 00000357 48FFC6                      inc rsi             ; пропускаем знак '+'
   370                                  
   371                                  .after_sign:
   372                                      ; ПРОВЕРКА НА ОТСУТСТВИЕ ЦИФР ПОСЛЕ ЗНАКА
   373 0000035A 803E00                      cmp byte [rsi], 0
   374 0000035D 7469                        je .format_error
   375                                      
   376                                      ; Загружаем константы для проверки диапазона
   377 0000035F 4C8B0C25[E8000000]          mov r9, [max_positive_div10]   ; 922337203685477580
   378 00000367 4C8B1425[F0000000]          mov r10, [min_negative_div10]  ; -922337203685477580
   379                                      
   380                                      ; ОБРАБОТКА ЦИФР
   381                                  .digit_loop:
   382 0000036F 8A16                        mov dl, [rsi]       ; текущий символ
   383 00000371 80FA00                      cmp dl, 0           ; нуль-терминатор?
   384 00000374 7445                        je .end_digits
   385                                      
   386                                      ; ПРОВЕРКА НА ЦИФРУ
   387 00000376 80FA30                      cmp dl, '0'
   388 00000379 724D                        jb .format_error
   389 0000037B 80FA39                      cmp dl, '9'
   390 0000037E 7748                        ja .format_error
   391                                      
   392 00000380 80EA30                      sub dl, '0'         ; преобразование символа в цифру
   393 00000383 480FB6D2                    movzx rdx, dl
   394                                      
   395                                      ; ПРОВЕРКА ПЕРЕПОЛНЕНИЯ
   396 00000387 4D85C0                      test r8, r8
   397 0000038A 7516                        jnz .negative_check
   398                                      
   399                                      ; ПРОВЕРКА ДЛЯ ПОЛОЖИТЕЛЬНЫХ ЧИСЕЛ
   400                                  .positive_check:
   401                                      ; Если текущее значение > max_div10, то ошибка
   402 0000038C 4C39CB                      cmp rbx, r9
   403 0000038F 7F3E                        jg .range_error
   404 00000391 7C06                        jl .positive_ok
   405                                      ; Если текущее значение == max_div10, то последняя цифра должна быть <= 7
   406 00000393 4883FA07                    cmp rdx, 7
   407 00000397 7F36                        jg .range_error
   408                                      
   409                                  .positive_ok:
   410                                      ; Умножаем текущий результат на 10
   411 00000399 480FAFD9                    imul rbx, rcx
   412                                      ; Добавляем цифру
   413 0000039D 4801D3                      add rbx, rdx
   414 000003A0 EB14                        jmp .next_digit
   415                                  
   416                                  .negative_check:
   417                                      ; ПРОВЕРКА ДЛЯ ОТРИЦАТЕЛЬНЫХ ЧИСЕЛ
   418                                      ; Отрицательное число - накапливаем положительное значение, затем сделаем отрицательным
   419                                      ; Сравниваем с положительным пределом, но проверяем другую логику
   420                                      
   421                                      ; Для отрицательных чисел мы строим положительное число, а затем инвертируем знак
   422                                      ; Проверка: если текущее положительное значение > max_div10, то после инверсии будет < min
   423 000003A2 4C39CB                      cmp rbx, r9
   424 000003A5 7F28                        jg .range_error
   425 000003A7 7C06                        jl .negative_ok
   426                                      ; Если текущее значение == max_div10, то последняя цифра должна быть <= 8 (для -2^63)
   427 000003A9 4883FA08                    cmp rdx, 8
   428 000003AD 7F20                        jg .range_error
   429                                      
   430                                  .negative_ok:
   431                                      ; Умножаем текущий результат на 10
   432 000003AF 480FAFD9                    imul rbx, rcx
   433                                      ; Добавляем цифру
   434 000003B3 4801D3                      add rbx, rdx
   435                                      
   436                                  .next_digit:
   437 000003B6 48FFC6                      inc rsi
   438 000003B9 EBB4                        jmp .digit_loop
   439                                  
   440                                  .end_digits:
   441                                      ; УЧЕТ ЗНАКА
   442 000003BB 4D85C0                      test r8, r8
   443 000003BE 7403                        jz .positive_num
   444                                      ; Для отрицательного числа инвертируем знак
   445 000003C0 48F7DB                      neg rbx
   446                                  
   447                                  .positive_num:
   448                                      ; УСПЕШНОЕ ЗАВЕРШЕНИЕ
   449 000003C3 4831C0                      xor rax, rax        ; успех
   450 000003C6 EB0C                        jmp .done
   451                                  
   452                                  .format_error:
   453 000003C8 B801000000                  mov rax, 1          ; ошибка формата
   454 000003CD EB05                        jmp .done
   455                                  
   456                                  .range_error:
   457 000003CF B802000000                  mov rax, 2          ; ошибка диапазона
   458                                  
   459                                  .done:
   460 000003D4 415A                        pop r10
   461 000003D6 4159                        pop r9
   462 000003D8 4158                        pop r8
   463 000003DA 5A                          pop rdx
   464 000003DB 59                          pop rcx
   465 000003DC 5D                          pop rbp
   466 000003DD C3                          ret
   467                                  
   468                                  ; ФУНКЦИЯ: int64_to_string
   469                                  ; Назначение: Преобразует 64-битное целое число в строку
   470                                  ; Вход: RAX - число, RDI - буфер для строки
   471                                  ; Выход: RDI содержит строку
   472                                  int64_to_string:
   473 000003DE 55                          push rbp
   474 000003DF 4889E5                      mov rbp, rsp
   475 000003E2 50                          push rax
   476 000003E3 53                          push rbx
   477 000003E4 51                          push rcx
   478 000003E5 52                          push rdx
   479 000003E6 57                          push rdi
   480 000003E7 4154                        push r12
   481                                      
   482 000003E9 4989FC                      mov r12, rdi        ; сохраняем начало буфера
   483 000003EC BB0A000000                  mov rbx, 10         ; основание системы счисления
   484 000003F1 4831C9                      xor rcx, rcx        ; счетчик цифр
   485                                      
   486                                      ; ОБРАБОТКА НУЛЯ
   487 000003F4 4885C0                      test rax, rax
   488 000003F7 7509                        jnz .not_zero
   489 000003F9 C60730                      mov byte [rdi], '0'
   490 000003FC C6470100                    mov byte [rdi+1], 0
   491 00000400 EB38                        jmp .done
   492                                      
   493                                  .not_zero:
   494                                      ; ОБРАБОТКА ЗНАКА
   495 00000402 4885C0                      test rax, rax       ; проверка знака числа
   496 00000405 7909                        jns .positive
   497 00000407 48F7D8                      neg rax             ; делаем число положительным
   498 0000040A C6072D                      mov byte [rdi], '-' ; добавляем знак минуса
   499 0000040D 48FFC7                      inc rdi
   500                                  
   501                                  .positive:
   502                                      ; ВЫДЕЛЕНИЕ ЦИФР ИЗ ЧИСЛА
   503                                  .divide_loop:
   504 00000410 4831D2                      xor rdx, rdx        ; обнуляем RDX для деления
   505 00000413 48F7F3                      div rbx             ; RDX:RAX / 10, остаток в RDX
   506 00000416 80C230                      add dl, '0'         ; преобразуем цифру в символ
   507 00000419 6652                        push dx             ; сохраняем цифру в стек
   508 0000041B 48FFC1                      inc rcx             ; увеличиваем счетчик цифр
   509 0000041E 4885C0                      test rax, rax       ; число стало нулем?
   510 00000421 75ED                        jnz .divide_loop
   511                                      
   512                                      ; ФОРМИРОВАНИЕ СТРОКИ ИЗ СТЕКА
   513 00000423 4C89E7                      mov rdi, r12
   514 00000426 803F2D                      cmp byte [rdi], '-' ; был ли знак минуса?
   515 00000429 7503                        jne .pop_loop
   516 0000042B 48FFC7                      inc rdi             ; пропускаем знак минуса
   517                                      
   518                                  .pop_loop:
   519 0000042E 6658                        pop ax              ; извлекаем цифру из стека
   520 00000430 8807                        mov [rdi], al       ; записываем в буфер
   521 00000432 48FFC7                      inc rdi
   522 00000435 E2F7                        loop .pop_loop
   523                                      
   524 00000437 C60700                      mov byte [rdi], 0   ; добавляем нуль-терминатор
   525                                      
   526                                  .done:
   527 0000043A 415C                        pop r12
   528 0000043C 5F                          pop rdi
   529 0000043D 5A                          pop rdx
   530 0000043E 59                          pop rcx
   531 0000043F 5B                          pop rbx
   532 00000440 58                          pop rax
   533 00000441 5D                          pop rbp
   534 00000442 C3                          ret
